---
title: "Introduction to sparsebn"
author: "Bryon Aragam"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to sparsebn}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Introduction goes here

## Example: Learning a Markov Chain

Suppose that the data is generated by a simple Markov chain:

$$X_1\to X_2\to X_3.$$

Assume unit influences between variables, i.e. $X_j\sim\mathcal{N}(0,1)$ and $X_{j} = X_{j-1} + \varepsilon$ with $\varepsilon\sim\mathcal{N}(0,1)$ for $j>1$. If $X=(X_1,X_2,X_3)$ then $X=B^TX+\varepsilon\sim\mathcal{N}(0,\Sigma)$, where we use the following parameters:

$$
B = \begin{pmatrix}
0 & 1 & 0 \\
0 & 0 & 1 \\
0 & 0 & 0
\end{pmatrix}, \quad
\Omega = \begin{pmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{pmatrix}, \quad
\Sigma = \begin{pmatrix}
3 & 2 & 1 \\
2 & 2 & 1 \\
1 & 1 & 1
\end{pmatrix}.
$$

To generate data from this model, first define the covariance matrix:
```{r}
mean.vector <- rep(0, 3)
covariance.matrix <- rbind(c(3,2,1),
                           c(2,2,1),
                           c(1,1,1))
```

Then we can generate some data using `mvtnorm::rmvnorm`:
```{r}
gaussian.data <- mvtnorm::rmvnorm(n = 100, mean = mean.vector, sigma = covariance.matrix)
```

In order to use the methods in the sparsebn package, we need to indicate what kind of data we are working with by wrapping the data into a `sparsebnData` object:
```{r message=FALSE, warning=FALSE}
library("sparsebn")
dat <- sparsebnData(gaussian.data, type = "continuous")
```

Now we can use this data to estimate $B$:
```{r}
dags.out <- estimate.dag(data = dat, 
                         lambdas.length = 20, 
                         edge.threshold = 10, 
                         verbose = FALSE)
dags.out
```

Note that the output is a _solution path_ (stored internally as a `sparsebnPath` object), instead of a single estimate. In order to select a particular DAG, we need to do model selection (not implemented yet).

As expected, the third estimate in our solution path gives the correct estimate:
```{r}
dags.out[[3]]
get.adjacency.matrix(dags.out[[3]])
plot(dags.out[[3]], 
     vertex.size = 50, 
     layout = t(matrix(c(0,1,10,1,20,1), nrow=2)))
```

## Another Example
